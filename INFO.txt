

1. Аутентификация пользователя:

Клиент отправляет логин и пароль.
Данные отправляются на сервер

Сервер проверяет данные пользователя:
Проверяет логин и пароль, сверяя их с данными в базе.

Если данные корректны:
Генерирует Access Token (короткоживущий, например, 15 минут).
Генерирует Refresh Token (долгоживущий, например, 7-30 дней).

Рекомендация по хранению токенов на клиенте:
Access Token: хранить в памяти приложения (например, в state или переменной).
Refresh Token: хранить в httpOnly-куки (куки недоступны из JavaScript и защищены от XSS-атак).


2. Использование Access Token для запросов к API:
Клиент отправляет запрос к защищённому API:

Включает Access Token в заголовок запроса:
http
Authorization: Bearer <Access_Token>

Сервер проверяет Access Token:

Проверяет подпись токена (используя секретный ключ или публичный ключ в случае RS256).
Проверяет срок действия токена (exp).
Проверяет данные пользователя (например, ID) и роли/права доступа (scope).
Ответ сервера:

Если токен валиден, сервер выполняет запрос и отправляет ответ.
Если токен недействителен или истёк:
Сервер возвращает код ошибки 401 Unauthorized с описанием.

3. Обновление Access Token с помощью Refresh Token:
Когда Access Token истекает:

Клиент отправляет запрос на сервер для обновления токена.
В запросе отправляется только Refresh Token (например, в httpOnly-куках).
Сервер проверяет Refresh Token:

Проверяет подпись токена.
Проверяет срок действия токена.
Проверяет наличие токена в базе данных или хранилище (для предотвращения использования отозванных токенов).
Сервер генерирует новые токены:

Создаёт новый Access Token.
При необходимости (например, если Refresh Token скоро истечёт) генерирует новый Refresh Token.
Возвращает токены клиенту.
Клиент сохраняет новые токены:

Access Token: заменяется в памяти приложения.
Refresh Token: заменяется в httpOnly-куках (если был обновлён).

4. Выход (Logout) пользователя:
Клиент отправляет запрос на выход:

Может отправляться запрос с Refresh Token на сервер.
Сервер помечает токен как недействительный:

Удаляет Refresh Token из базы данных/хранилища.
Access Token становится автоматически недействительным, когда истекает его срок.
Клиент очищает токены:

Удаляет Access Token из памяти приложения.
Удаляет Refresh Token из куки (если это требуется).

5. Обработка сценариев безопасности:
Проверка компрометации Refresh Token:

Если Refresh Token скомпрометирован (например, при утечке):
Отозвать все токены пользователя (обновить хэш или идентификатор в базе).
Требовать повторной аутентификации.
Хранение токенов:

Access Token не должен храниться в локальном или сессионном хранилище (LocalStorage/SessionStorage), так как они уязвимы к XSS-атакам.
Refresh Token следует хранить в httpOnly-куках, чтобы минимизировать риск компрометации.
Защита от CSRF:

Для запросов с Refresh Token (если используется в куках), добавлять CSRF-токен в заголовок запроса.
Общий цикл работы:
Пользователь аутентифицируется (логин и пароль).
Сервер выдаёт Access и Refresh токены.
Клиент использует Access Token для запросов к API.
При истечении Access Token клиент обновляет его с помощью Refresh Token.
При завершении сеанса клиент выходит, сервер отзывает токены.
Этот процесс позволяет поддерживать баланс между безопасностью и удобством, минимизируя риск компрометации.